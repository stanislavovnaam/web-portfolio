<!--
Функции:
    - Холст для рисования
    - Размер, цвет кисти
    - Заливка
    - Очистка холста
    - Сохранение рисунка
    
Новые функции:
    - Заливка как отдельный инструмент
    - Заливка замкнутых фигур
    - Инструмент Ластик
    - Шаг назад / Шаг вперед для исправлений
-->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Приложение для рисования</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        #toolbar {
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }

        #canvas {
            border: 1px solid #333;
            background: white;
            cursor: crosshair;
        }

        button,
        select,
        input[type=color],
        input[type=range] {
            padding: 5px 10px;
            font-size: 14px;
        }

        label {
            font-size: 14px;
        }
    </style>
</head>

<body>

    <div id="toolbar">
        <label>Инструмент:
            <select id="tool">
                <option value="brush">Кисть</option>
                <option value="fill">Заливка</option>
                <option value="eraser">Ластик</option>
            </select>
        </label>

        <label>Цвет:
            <input type="color" id="color" value="#000000" />
        </label>

        <label>Размер:
            <input type="range" id="size" min="1" max="50" value="5" />
        </label>

        <button id="undo" title="Шаг назад">←</button>
        <button id="redo" title="Шаг вперед">→</button>
        <button id="clear">Очистить</button>
        <button id="save">Сохранить</button>
    </div>

    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        (() => {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            let drawing = false;
            let tool = 'brush';
            let brushColor = '#000000';
            let brushSize = 5;
            let lastX = 0,
                lastY = 0;

            let history = [];
            let historyStep = -1;
            const maxHistory = 50;
            
            // DOM элементы
            const toolSelect = document.getElementById('tool');
            const colorInput = document.getElementById('color');
            const sizeInput = document.getElementById('size');
            const undoBtn = document.getElementById('undo');
            const redoBtn = document.getElementById('redo');
            const clearBtn = document.getElementById('clear');
            const saveBtn = document.getElementById('save');

            // Инициализация белого холста
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveHistory();

            

            // Сохранить состояние холста в историю
            function saveHistory() {
                if (historyStep < history.length - 1) {
                    history = history.slice(0, historyStep + 1);
                }
                if (history.length >= maxHistory) {
                    history.shift();
                    historyStep--;
                }
                history.push(canvas.toDataURL());
                historyStep++;
                updateUndoRedoButtons();
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = historyStep <= 0;
                redoBtn.disabled = historyStep >= history.length - 1;
            }

            // Нарисовать линию (кисть или ластик)
            function drawLine(x1, y1, x2, y2) {
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = brushSize;
                ctx.strokeStyle = tool === 'eraser' ? 'white' : brushColor;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // Получить позицию мыши относительно канваса
            function getPos(e) {
                const rect = canvas.getBoundingClientRect();
                let x, y;
                if (e.touches && e.touches.length) {
                    x = e.touches[0].clientX - rect.left;
                    y = e.touches[0].clientY - rect.top;
                } else {
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                return {
                    x,
                    y
                };
            }

            // Алгоритм заливки (Flood fill)
            function floodFill(x, y, fillColor) {
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imgData.data;

                const width = canvas.width;
                const height = canvas.height;

                // Цвет пикселя в [r, g, b, a]
                function getPixel(pos) {
                    return [data[pos], data[pos + 1], data[pos + 2], data[pos + 3]];
                }
                // Сравнить цвета
                function colorsMatch(a, b) {
                    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
                }
                // Записать цвет
                function setPixel(pos, color) {
                    data[pos] = color[0];
                    data[pos + 1] = color[1];
                    data[pos + 2] = color[2];
                    data[pos + 3] = color[3];
                }

                // Целевой цвет на исходном пикселе
                const pxPos = (y * width + x) * 4;
                const targetColor = getPixel(pxPos);

                // Цвет заливки
                const fillRGBA = hexToRgba(fillColor);

                // Если цвета совпадают, ничего не заливать
                if (colorsMatch(targetColor, fillRGBA)) return;

                const stack = [];
                stack.push([x, y]);

                while (stack.length) {
                    const [cx, cy] = stack.pop();

                    const pos = (cy * width + cx) * 4;
                    const currentColor = getPixel(pos);

                    if (colorsMatch(currentColor, targetColor)) {
                        setPixel(pos, fillRGBA);

                        if (cx > 0) stack.push([cx - 1, cy]);
                        if (cx < width - 1) stack.push([cx + 1, cy]);
                        if (cy > 0) stack.push([cx, cy - 1]);
                        if (cy < height - 1) stack.push([cx, cy + 1]);
                    }
                }

                ctx.putImageData(imgData, 0, 0);
            }

            // Преобразование HEX в RGBA (массив)
            function hexToRgba(hex) {
                hex = hex.replace('#', '');
                let r, g, b;
                if (hex.length === 3) {
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                } else {
                    r = parseInt(hex.substring(0, 2), 16);
                    g = parseInt(hex.substring(2, 4), 16);
                    b = parseInt(hex.substring(4, 6), 16);
                }
                return [r, g, b, 255];
            }

            // События рисования
            function pointerDown(e) {
                e.preventDefault();
                const pos = getPos(e);
                if (tool === 'fill') {
                    floodFill(Math.floor(pos.x), Math.floor(pos.y), brushColor);
                    saveHistory();
                    return;
                }
                drawing = true;
                lastX = pos.x;
                lastY = pos.y;
            }

            function pointerMove(e) {
                if (!drawing) return;
                e.preventDefault();
                const pos = getPos(e);
                drawLine(lastX, lastY, pos.x, pos.y);
                lastX = pos.x;
                lastY = pos.y;
            }

            function pointerUp(e) {
                if (!drawing) return;
                drawing = false;
                saveHistory();
            }

            // Обработчики toolbar
            toolSelect.addEventListener('change', () => {
                tool = toolSelect.value;
                canvas.style.cursor = tool === 'fill' ? 'pointer' : 'crosshair';
            });

            colorInput.addEventListener('input', () => {
                brushColor = colorInput.value;
            });

            sizeInput.addEventListener('input', () => {
                brushSize = sizeInput.value;
            });

            undoBtn.addEventListener('click', () => {
                if (historyStep <= 0) return;
                historyStep--;
                let img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = history[historyStep];
                updateUndoRedoButtons();
            });

            redoBtn.addEventListener('click', () => {
                if (historyStep >= history.length - 1) return;
                historyStep++;
                let img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = history[historyStep];
                updateUndoRedoButtons();
            });

            clearBtn.addEventListener('click', () => {
                ctx.fillStyle = 'white';
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                saveHistory();
            });

            saveBtn.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = 'drawing.png';
                link.href = canvas.toDataURL();
                link.click();
            });

            // Поддержка мыши и касаний
            canvas.addEventListener('mousedown', pointerDown);
            canvas.addEventListener('mousemove', pointerMove);
            canvas.addEventListener('mouseup', pointerUp);
            canvas.addEventListener('mouseleave', () => {
                if (drawing) {
                    drawing = false;
                    saveHistory();
                }
            });

            canvas.addEventListener('touchstart', pointerDown);
            canvas.addEventListener('touchmove', pointerMove);
            canvas.addEventListener('touchend', pointerUp);
            canvas.addEventListener('touchcancel', pointerUp);
        })();
    </script>

</body></html>
